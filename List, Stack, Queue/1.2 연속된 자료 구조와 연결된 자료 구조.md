응용 프로그램에서 데이터를 처리하기 이전, 먼저 데이터를 어떻게 저장할 것인가를 결정해야 한다. 

작업의 종류와 빈도에 따라 달라지는데, 응용 프로그램이 제대로 동작하는 것을 기본으로 동시에 지연 시간, 사용 메모리 또는 기타 매개변수 측면에서 최선의 성능을 제공하도록 구현 방법을 선택해야 한다. 

**어떠한 자료 구조를 선택할 것인가를 결정함에 있어 적합한 지표로 알고리즘 복잡도 혹은 시간 복잡도가 있다.** 

**시간 복잡도**는 **특정 작업을 수행하는데 걸리는 시간을 데이터 크기에 대한 수식으로 표현하는 방식**이다. 

따라서 시간 복잡도는 데이터 크기가 변경되면 연산 시간이 어떻게 변하는지를 보여주고, 서로 다른 연산의 시간 복잡도는 그 내부에서 데이터를 어떻게 저장하여 사용하는가에 따라 크기가 달라진다. 

> **1.2.1 연속된 자료 구조**
> 
> - **연속된 자료구조, Contiguous Data Structure**는 모든 원소를 단일 메모리 Chunk에 저장한다.
>     
>     <img src = './image/Contiguous Data Strucure.png'>
>     
>     연속된 자료 구조를 표현한 다이어그램, 모든 원소는 같은 크기의 타입이고 sizeof로 표시된다. 
>     
>     **첫 번째 메모리 주소**를 **Base Address**라고 한다. 
>     
>     이러한 자료 구조에서는 배열의 전체 크기에 상관 없이 위 수식을 사용하여 모든 원소에 곧바로 접근할 수 있다. 따라서 **데이터 접근 시간은 항상 일정**하다. 이러한 경우를 Big-O 표기법으로 나타내면 **O(1)**이다. 
>     
>     배열의 유형은 정적 배열, 동적 배열 두 가지로 나눌 수 있다. 
>     
>     **정적 배열은 선언된 블록이 끝나면 소멸되는 반면, 동적 배열은 프로그래머가 생성할 시점과 해체할 시점을 자유롭게 결정할 수 있다.** 
>     
>     두 가지 유형 중에서 필요에 따라 적절한 배열을 선택하여 사용하면 되고, 두 가지 유형 모두 다양한 연산에서 동일한 성능을 나타낸다. 
>     
>     **정적 배열은 int arr[size]; 형태로 선언**한다. 
>     
>     **동적 배열은 int* arr = new int[size]; 형태로 선언**한다. 
>     
>     **정적 배열**은 **Stack 메모리 영역에 할당**되기 때문에 함수를 벗어날 때 **자동으로 해제** 된다. 
>     
>     반면 **동적 배열**은 **Heap 영역에 할당**되며 **사용자가 직접 해제하기 전까지 유지**된다. 
>     
>     배열과 같은 연속된 자료 구조에서 각 원소는 서로 인접해있기 때문에 하나의 원소에 접근할 때 그 옆에 있는 원소 몇 개도 함께 Cache로 가져온다. 그러므로 다시 주변 원소에 접근할 때에는 해당 원소를 Cache에서 가져오게 되며, 이 작업은 매우 빠르게 동작한다. 이와 같은 속성을 **Cache Locality**라고 한다. 
>     
>     어떤 연산의 점근적 시간 복잡도 계산에는 영향을 주지 않지만 실제 동작에서 배열처럼 연속된 원소에 매우 빠르게 접근할 수 있다는 것은 매우 큰 장점이 된다. 
>     
>     배열에서 모든 원소에 순차적으로 접근하는 경우, 첫 번째 원소를 가져온 후 다음 원소는 Cache에서 바로 참조할 수 있으므로 **배열은 Cache Locality가 좋다고 할 수 있다.** 
>     

> **1.2.2 연결된 자료 구조**
> 
> - **연결된 자료 구조, Linked Data Structure**는 Node라고 하는 여러 개의 메모리 Chunk에 데이터를 저장하며, 이 경우 서로 다른 메모리 위치에 데이터가 저장된다.
>     
>     <img src = './image/Linked Data Structure.png'>
>     
>     연결된 자료 구조를 표현한 다이어그램, 포인터 == next
>     
>     위와 같은 형태로 구성된 자료 구조를 **Linked List**라고 한다. 
>     
>     Linked List의 기본 구조에서 **각각의 Node**는 **저장할 데이터**와 다음 **Node를 가리키는 Pointer**를 가지고 있다. 
>     
>     **맨 마지막 Node에서 다음 Node의 Pointer 대신 자료 구조의 끝을 나타내는 NULL을 가진다.** 
>     
>     Linked List에서 특정 원소에 접근하려면 List의 시작 부분, 즉 **Head 부분부터 시작해 원하는 원소에 도달할 때까지 Next Pointer를 따라 이동**해야 한다. 
>     
>     그러므로 i번째 원소에 접근하려면 Linked List 내부를 i번 이동하는 작업이 필요하므로 원소 접근 시간은 Node 갯수에 비례하며, 시간 복잡도로 표현했을 때 **O(n)**이다. 
>     
>     배열과 달리 Linked List는 Pointer를 이용하여 원소의 삽입 또는 삭제를 매우 빠르게 수행할 수 있다. 
>     
>     <img src = './image/Linked List.png'>
>     
>     Linked List에 새로운 원소를 추가하는 방법, 중간에 새로운 원소를 삽입하는 동작을 나타내는 다이어그램 
>     
>     **새로운 원소를 삽입하기 위해서는 새로운 Node를 생성하고, 각 Node의 Next Pointer를 수정해야 한다.** 
>     
>     먼저 새로 추가한 Node(i = 2)의 Next Pointer가 다음 Node(i = 3)을 가리키게 한다. 그리고 이전 Node(i = 1)의 Next Pointer가 다음 Node(i = 3)을 가리키던 것을 제거하고, 새로운 Node(i = 2)를 가리키도록 설정한다. 다음과 같은 방식으로 새로운 Node가 Linked List에 추가된다. 
>     
>     마찬가지로 **기존 원소를 제거하려면 삭제할 원소가 더 이상 Linked List에 연결되어 있지 않도록 Next Pointer를 수정하면 된다.** 
>     
>     Linked List에서는 원소가 메모리에 연속적으로 저장되지 않기 때문에 **Cache Locality를 기대할 수 없다.** 즉, **현재 Node가 가리키는 다음 Node에 직접 방문하지 않고 다음 원소를 Cache로 가져올 수 있는 방법은 없다.** 
>     
>     따라서 배열과 Linked List에서 모든 원소를 차례로 방문하는 작업은 이론적으로 같은 시간 복잡도를 가지지만 실제로는 Linked List의 성능이 조금 떨어진다. 
>     

> **1.2.3 비교**
> 
> - 구현할 작업의 요구 조건 및 사용 빈도에 따라 배열과 Linked List 중 하나를 선택하거나, 두 개를 조합하여 응용 프로그램을 개발해야 한다.
>     
>     <img src = './image/Comparison of Data Structurepng'>
>     
>     배열과 Linked List는 매우 범용적이며 많은 응용 프로그램에서 데이터를 저장하는 용도로 사용되고 있다. 따라서 이 자료 구조의 구현은 버그가 없어야 하고, 최대한 효율적으로 동작해야 한다. 
>     
>     사용자가 직접 이들 자료 구조를 구현하지 않아도 되도록 CPP는 std::array, std::vector, std::list와 같은 다양한 자료 구조 Class를 제공한다. 
>     

> **1.2.4 C 스타일 배열의 제약 사항**
> 
> - 메모리 할당과 해제를 수동으로 처리해야 한다. 메모리를 해제하지 못하면 메모리 Leak이 발생할 수 있고, 이 경우 해당 메모리 영역을 사용할 수 없다.
> - [] 연산자에서 배열의 크기보다 큰 원소를 참조하는 것을 검사하지 못한다. 잘못 사용하면 Segmentation Fault 혹은 메모리 손상으로 이어질 수 있다.
> - 배열을 중첩해서 사용할 경우, 문법이 너무 복잡해서 코드를 이해하기 어렵다.
> - Deep Copy가 기본으로 동작하지 않는다. 수동 구현이 필요하다.