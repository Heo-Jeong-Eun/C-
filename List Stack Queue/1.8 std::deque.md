std::deque는 배열 기반, 연결 리스트 기반 컨테이너 두 가지 방식이 섞여 있는 형태이며, 각각의 장점을 가지고 있다. 

std::vector는 가변 길이 배열이고, push_front(), pop_front() 같은 함수는 비용이 많이 드는 작업인데, std::deque를 사용하면 이와 같은 단점을 극복할 수 있다. 

**std::deque는 양방향 큐, Double Ended Queue의 약자이다.** 

> **1.8.1 덱의 구조**
>
> **std::deque의 표준 동작 필요 조건** 
>
> - push_front(), pop_front(), push_back(), pop_back() 동작이 O(1) 시간 복잡도로 동작해야 한다.
> - 모든 원소에 대해 임의 접근 동작이 O(1) 시간 복잡도로 동작해야 한다.
> - std::deque 중간에서 원소 삽입 삭제는 O(n) 시간 복잡도로 동작해야 하며, 실제로는 최대 n / 2 단계로 동작한다. 이때 n은 std::deque의 크기이다.
> 
> std::deque의 동작 필요 조건을 확인해보면, **std::deque은 양방향으로 매우 빠르게 확장**할 수 있어야하며, **모든 원소에 임의 접근을 제공**해야 한다는 것을 알 수 있다. 
> 
> 따라서 자료 구조가 std::vector와 비슷하지만, 앞쪽과 뒤쪽 모두 확장할 수 있다는 점이 다르다. 
>
> 원소 삽입과 삭제 시 n / 2 단계를 허용한다는 점에서 이 연산이 모든 원소를 이동시키는 동작을 수행한다는 점을 예상할 수 있으며, 이러한 원소 이동은 항상 오른쪽으로 이동하지 않는다. 
>
>원소 삽입 위치에서 가장 가까운 끝 쪽으로 나머지 원소를 이동해도 된다. 특정 위치에서 가장 가까운 끝은 컨테이너 내부의 삽입 위치에서 n / 2 이상 떨어져 있을 수 없기 때문에 최대 n / 2 단계의 시간 복잡도를 가진다. 
>
>std::deque은 단일 메모리 청크를 사용하지 않는다. 대신 **크기가 같은 여러 개의 메모리 청크를 사용하여 데이터를 저장**한다. 
이 경우 청크의 인덱스 및 크기를 이용하여 특정 위치의 원소가 어느 청크에 저장되어 있는지 알 수 있다. 
>
>모든 메모리 청크 주소를 연속적인 메모리 구조에 저장해놓고 사용하면 O(1)의 시간 복잡도로 원소의 임의 접근이 가능해진다. 따라서 std::deque의 구조는 배열, std::vector와 유사하다. 
>
> ```cpp
> std::deque<int> deq = {1, 2, 3, 4, 5};
> 
> deq.push_front(0); // 맨 앞에 0 추가 {0, 1, 2, 3, 4, 5}
> deq.push_back(6); // 맨 뒤에 6 추가 {0, 1, 2, 3, 4, 5, 6}
> deq.insert(deq.begin() + 2, 10); // 맨 앞에서 2칸 뒤에 10 추가 {0, 1, 10, 2, 3, 4, 5, 6}
> deq.pop_back(); // 맨 뒤 원소 삭제 {0, 1, 10, 2, 3, 4, 5}
> deq.pop_front(); // 맨 앞 원소 삭제 {1, 10, 2, 3, 4, 5}
> deq.erase(deq.begin() + 1); // {1, 2, 3, 4, 5}
> deq.erase(deq.begin() + 3, deq.end()) // {1, 2, 3}
> ```
> 
> **std::deque**도 **사용자 정의 할당자를 지정**할 수 있다. 
>
> std::deque을 초기화할 때 템플릿 두 번쨰 매개 변수에 할당자를 지정할 수 있는데, 할당자가 객체의 일부가 아니라 타입의 일부라는 것을 주의해야 한다. 
>
> 이는 **서로 다른 할당자를 사용하는 두 개의 std::vector 또는 두 개의 std::deque 객체를 서로 비교할 수 없음을 의미한다.** 
> 
> 마찬가지로 서로 다른 할당자를 사용하는 객체에 대해 할당 또는 복사 생성자를 사용할 수도 없다.