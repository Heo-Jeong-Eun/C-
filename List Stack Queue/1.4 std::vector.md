std::array는 C 스타일 배열의 향상된 버전이다. 하지만 std::array는 실제 응용 프로그램 개발에서 유용하게 사용할 수 있는 기능 몇 가지를 제공하지 않는다는 단점이 있다.

- std::array의 크기는 Compile 시간에 결정되는 상수이어야 한다. 따라서 프로그램 실행 중간에 변경할 수 없다.
- 크기가 고정되어 있어서 원소를 추가하거나 삭제할 수 없다.
- std::array의 메모리 할당 방법을 변경할 수 없다. 항상 Stack 메모리를 사용한다.

실제 응용 프로그램에서 데이터는 동적이며 고정 크기가 아니기 때문에 std::array를 사용하는 것이 항상 좋지는 않다.

> **1.4.1 std::vector - 가변 크기 배열**
>
>
> 가변 크기의 데이터를 처리할 수 있는 컨테이너가 필요한데, **std::vector**를 사용하게 되면 **고정 크기 문제를 해결**할 수 있다. std::vector는 **초기화 과정에 데이터 크기를 제공하지 않아도 된다.**
>
> ```cpp
> // 크기가 0인 Vector 선언
> std::vector<int> vec;
> 
> // 지정한 초기값으로 이루어진 크기가 5인 Vector 선언
> std::vector<int> vec = {1, 2, 3, 4, 5};
> 
> // 크기가 10인 Vector 선언
> std::vector<int> vec(10);
> 
> // 크기가 10이고, 모든 원소가 5로 초기화된 Vector tjsdjs
> std::vector<int> vec(10, 5);
> ```
>
> std::vector는 **원소 크기를 지정하지 않고 선언이 가능**하다. 만약 크기를 명시적으로 지정하지 않고나 초기값을 지정하여 크기를 유추할 수 있게 작성하지 않은 경우, **Compiler 구현 방법에 따른 용량, Capacity을 갖는 std::vector가 생성**된다.
>
> **std::vector의 크기**는 **std::vector에 실제로 저장된 원소 개수를 나타내는 용어**이며, 용량과는 다른 의미이다.
>
> 따라서 첫 번째 초기화의 경우, 크기는 0이지만 용량은 0 또는 작은 양수일 수 있다.
>
> std::vector에 **새로운 원소를 추가**하려면 **push_back()또는 insert() 함수**를 사용한다.
>
> **push_back()** 함수는 std::vector의 **맨 마지막에 새로운 원소를 추가**한다.
>
> push_back()은 std::vector에서 자주 사용되는 연산으로 매우 빠르게 동작한다.
>
> ```cpp
> push_back(val):
> 	if size < capacity // 새 원소를 추가할 공간이 있는 경우 
> 		- 마지막 원소 다음에 val을 저장한다. 
> 		- vector의 크기를 1만큼 증가
> 		- return;
> 
> 	if vector is already full // 할당된 메모리 공간이 가득 차 있는 경우 
> 		- 2 * size 크기의 메모리를 새로 할당
> 		- 새로 할당한 메모리로 기존 원소를 전부 복사 / 이동
> 		- 데이터 포인터를 새로 할당한 메모리 주소로 지정
> 		- 마지막 원소 다음에 val을 저장, vector 크기를 1만큼 증가 
> ```
>
> 맨 뒤에 원소를 삽입할 때, **뒤 쪽에 남아 있는 공간이 있다면 O(1)의 시간**이 걸린다. 하지만 **공간이 충분하지 않으면** 모든 원소를 복사 / 이동해야하며 이때는 **O(n)의 시간**이 걸린다.
>
> 하지만 O(n)의 시간은 n개의 원소를 추가할 때만 발생하므로 평균 push_back()의 연산시간은 사실상 O(1)에 가깝다. 따라서 push_back()은 매우 빠르게 동작하고, 이 때문에 std::vector을 많이 사용한다.
>
> **insert()** 함수는 삽입할 위치를 나타내는 반복자를 첫 번째 인자로 받음으로써 **원하는 위치에 원소를 추가**할 수 있다.
>
> insert() 함수의 경우, **지정한 반복자 위치 다음의 모든 원소를 이동시키는 연산이 필요**하다. 필요한 경우 메모리를 새로 할당하는 작업도 수행된다. 원소를 이동시키는 작업 때문에 insert() 함수의 경우 **O(n)의 시간**이 걸린다.
>
> 하지만 std::vector의 경우 push_front() 함수를 지원하지 않으므로, 맨 앞에 새로운 원소를 추가하려면 원소 삽입 위치를 인자로 받는 insert() 함수를 사용해야 한다.
>
> ```cpp
> // 5개의 정수를 갖는 vector를 정의 
> std::vector& lt;
> int& gt;
> vec = {1, 2, 3, 4, 5};
> 
> // vector의 맨 앞에 새로운 원소를 추가하려면 insert() 함수를 사용해야 한다. 
> vec.insert(vec.begin(), 0);
> ```
>
> ```cpp
> // 비어 있는 vector 생성 : {}
> std::vector<int> vec;
> 
> // 맨 뒤에 1 추가 : {1}
> vec.push_back(1);
> 
> // 맨 뒤에 2 추가 : {1, 2}
> vec.push_back(2);
> 
> // 맨 앞에 0 추가 : {0, 1, 2}
> vec.insert(vec.begin(), 0);
> 
> // 1 앞에 4 추가 : {0, 4, 1, 2}
> vec.insert(find(vec.begin(), vec.end(), 1), 4));
> ```
>
> **push_back()과 insert()의 단점** 중 하나는 이들 **함수가 추가할 원소를 먼저 임의로 생성한 후, std::vector 버퍼 내부 위치로 복사 또는 이동을 수행한다는 점**이다.
>
> 이러한 단점은 **새로운 원소가 추가될 위치에서 해당 원소를 생성하는 방식으로 최적화**할 수 있으며, **emplace_back()** 과 **emplace() 함수**에 구현되어 있다.
>
> 이 경우 새 원소 위치에서 곧바로 객체가 생성되기 때문에 이들 함수 인자에 생성된 객체를 전달하는 것이 아니라 생성자에 필요한 매개 변수를 전달해야 한다. 그러면 emplace_back() 또는 emplace() 함수가 전달된 생성자 인자를 적절하게 사용해 객체를 생성하고 삽입한다.
>
> std::vector는 **원소 제거**를 위해 **pop_back()과 erase() 함수를 제공**한다.
>
> **pop_back()** 함수는 std::vector에서 **맨 마지막 원소를 제거**하며, 그 결과 **std::vector의 크기는 1만큼 줄어든다.**
>
> **erase()** 함수는 **두 가지 형태로 Overloading**이 되어 있다. 첫 번째는 **반복자 하나를 인자로 받아 해당 위치 원소를 제거하는 것**이고, 두 번째는 **범위의 시작과 끝을 나타내는 반복자를 받아 시작부터 끝 바로 앞 원소까지 제거**한다. 즉, **시작 위치 원소는 제거되지만 끝 위치 원소는 제거되지 않는다.**
>
> **pop_back()** 함수는 남아 있는 위치를 조정할 필요가 없으므로 매우 빠르게 동작하고, **시간 복잡도는 O(1)** 이다. 반면 **erase()** 함수는 특정 위치 원소를 삭제한 후, 뒤쪽 원소를 모두 앞으로 이동시켜야하기 때문에 **O(n)의 시간**이 소요된다.
>
> ```cpp
> // 10개의 데이터를 가지고 있는 vector 생성
> std::vector<int> vec = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
> 
> // 맨 마지막 원소 하나를 제거한다. : {0, 1, 2, 3, 4, 5, 6, 7, 8};
> vec.pop_back();
> 
> // 맨 처음 원소 하나를 제거한다. : {1, 2, 3, 4, 5, 6, 7, 8};
> vec.erase(vec.begind());
> 
> // 1번째 원소부터 4번째 앞 원소까지 제거한다. : {1, 5, 6, 7, 8};
> vec.erase(vec.begin + 1, vec.begin() + 4);
> ```
>

이 외에도 유용한 여러 std::vector 멤버 함수를 추가적으로 소개한다.

- **clear()** : 모든 원소를 제거하여 **완전히 비어있는 std::vector로 만든다.**
- **reverse(capacity)** : std::vector에서 **사용할 용량을 지정**한다. **매개 변수로 지정한 값이 현재 용량보다 크면 메모리를 매개 변수 크기만큼 재할당**한다. 매개 변수 값이 현재 용량보다 작거나 같으면 아무런 동작을 하지 않는다. 이 함수가 std::vector의 **크기를 변경하지는 않는다.**
- **shrink_to_fit()** : **여분의 메모리 공간을 해제하는 용도로 사용**된다. 이 함수를 호출하면 std::vector의 용량이 std::vector 크기와 같게 설정된다. std::vector 크기가 더 이상 변경되지 않을 때 사용하면 유리하다.

> **1.4.2 std::vector 할당자**
>
>
> std::vector는 **Template 매개 변수에서 데이터 타입 다음에 할당자를 전달할 수 있다.** 이 기능을 사용하면 std::array의 단점을 해결할 수 있다.
>
> 사용자 정의 할당자를 사용하려면 정해진 Interface를 따라야 한다. std::vector는 메모리 접근과 관련된 대부분의 동작에서 할당자 함수를 사용하므로 할당자는 allocate(), deallocate(), construct(), destroy() 등의 함수를 제공해야 한다.
>
> 할당자는 메모리 할당과 해제, 그리고 여타 동작에서 데이터를 손상시키지 않도록 주의해야한다.
>
> 일반적인 Heap 메모리 대신 자체적인 메모리 풀 또는 이와 유사한 자원을 사용하거나 자동 메모리 관리가 필요한 응용 프로그램을 만들어야 하는 경우에 사용자 정의 할당자를 사용하면 유용하다.
>