**반복자는 포인터와 비슷하지만, STL 컨테이너에 대해 공통의 인터페이스를 제공한다.**

반복자를 이용한 연산은 **어떤 컨테이너에서 정의된 반복자인지에 따라 결정**된다.

std::vector와 배열의 경우 연속된 자료 구조를 사용하기 때문에 특정 위치의 원소에 곧바로 접근할 수 있다. 이러한 반복자를 **임의 접근 반복자, Random Access Iterator**라고 한다.

std::forward_list의 경우 역방향으로 이동하는 기능을 제공하지 않으며, 바로 이전 노드로 이동하려면 맨 처음 노드부터 시작해서 찾아가야 한다. 따라서 std::forward_list에서는 증가 연산만 가능하며 이러한 반복자를 **순방향 반복자, Forward Iterator**라고 한다.

반복자 타입에 따라 사용할 수 있는 advance(), next(), prev() 함수가 있다.

**advence()** 함수는 **반복자와 거리 값을 인자**로 받고, 반복자를 **거리 값만큼 증가**시킨다.

**next()와 prev()** 의 경우 **반복자와 거리 값을 인자**로 받고, 해당 반복자에서 **지정한 거리만큼 떨어진 위치의 반복자를 반환**한다.

이 함수들은 해당 반복자가 지원하는 경우에만 동작한다.

> **1.6.1 다양한 반복자에서 이동하기**
>
>
> std::vector 반복자를 사용해 데이터로부터 유용한 정보를 검색하는 방법을 찾고, std::forward_list를 사용해 같은 작업을 반복하며 std::vector 반복자와 다른 점을 확인한다.
>
> 1. 필요한 **Header File을 포함**한다.
     >
     >     ```cpp
>     #include <iostream>
>     #include <forward_list>
>     #include <vector>
>     ```
>
> 2. **std::vector를 사용**해 **최근 경기 우승자 명단을 작성**한다.
     >
     >     ```cpp
>     int main() {
>       std::vector<std::string> vec = {
>               "Lewis Hamilton", "Lewis Hamilton", "Nico Roseberg",
>               "Sebastian Vettel", "Lewis Hamilton", "Sebastian Vettel",
>               "Sebastian Vettel", "Sebastian Vettel", "Fernando Alonso"
>       };
>     
>       auto it = vec.begin(); // 상수 시간
>       std::cout << "가장 최근 우승자: " << *it << std::endl;
>     
>       it += 8; // 상수 시간
>       std::cout << "8년전 우승자: " << *it << std::endl;
>     
>       advance(it, -3); // 상수 시간
>       std::cout << "그후 3년 뒤 우승자: " << *it << std::endl;
>     ```
>
> 3. **std::forward_list를 이용**해 **같은 작업을 수행**하고, **std::vecor와 차이점**을 살핀다.
     >
     >     ```cpp
>     std::forward_list<std::string> fwd(vec.begin(), vec.end());
>     
>       auto it1 = fwd.begin();
>       std::cout << "가장 최근 우승자: " << *it1 << std::endl;
>     
>       advance(it1, 5); // 선형 시간
>       std::cout << "5년전 우승자: " << *it1 << std::endl;
>     
>       // std::forward_list는 순방향으로만 이동할 수 있으므로
>       // 아래 코드는 에러가 발생합니다.
>       // advance(it1, -2);
>     }
>     ```
>
> 4. 아래 경우 다음과 같은 에러가 발생한다.
     >
     >     ```cpp
>     it1 += 2;
>     
>     no match for 'operator +=' (operand types are std::_Fwd_list_iterator<int>>' and 'int')
>     ```
>
>
> std::forward_list는 단일 연결 리스트를 구현해 놓은 래퍼일 뿐이다.
>
> std::vector에서는 특정 원소에 즉각적으로 접근할 수 있으므로 **std::vector 반복자의 덧셈과 뺄셈은 O(1)** 이다.
>
> 반면 std::forward_list는 연속적인 순회를 통해서만 특정 원소에 접근할 수 있다. 그러므로 **std::forward_list의 덧셈 시간 복잡도는 O(n)** 이고, n은 순회할 횟수를 나타낸다.
>

> **1.6.2 기본적인 사용자 정의 컨테이너 구현**
>
>
> std::forward_list와 유사하면서 더 많은 기능을 제공하는 사용자 정의 컨테이너를 만든다.
>
> 1. 필요한 **Header File을 포함**하고, singly_ll 구현에 필요한 **Single Node Class** singly_ll_node를 정의한다.
     >
     >     ```cpp
>     #include <iostream>
>     #include <algorithm>
>     
>     struct singly_ll_node {
>       int data;
>       singly_ll_node *next;
>     };
>     ```
>
> 2. singly_ll_node Class 구현, **singly_ll_node를 사용하는 연결 리스트 Class**이다.
     >
     >     ```cpp
>     class singly_ll {
>     public:
>       using node = singly_ll_node;
>       using node_ptr = node *;
>     
>     private:
>       node_ptr head;
>     ```
>
> 3. std::forward_list Class에도 있는 **push_front()와 pop_front() 함수를 구현**한다.
     >
     >     ```cpp
>     public:
>       void push_front(int val) {
>         auto new_node = new node{val, NULL};
>         if (head != NULL)
>             new_node->next = head;
>         head = new_node;
>       }
>     
>       void pop_front() {
>         auto first = head;
>         if (head) {
>             head = head->next;
>             delete first;
>         }
>       }
>     ```
>
> 4. ngly_ll_node Class의 **기본 반복자를 구현**한다. 이 반복자는 **생성자**와 **접근자**를 가진다.
     >
     >     ```cpp
>     	struct singly_ll_iterator {
>     	  private:
>           node_ptr ptr;
>     	
>     	  public:
>           singly_ll_iterator(node_ptr p) : ptr(p) {}
>     	
>           int &operator*() { return ptr->data; }
>     	
>           node_ptr get() { return ptr; }
>     ```
>
> 5. 선행 증가와 후행 증가를 위한 **++ 연산자 함수를 구현**한다.
     >
     >     ```cpp
>     			singly_ll_iterator &operator++() // 선행 증가
>     		  {
>     		      ptr = ptr->next;
>     		      return *this;
>     		  }
>     		
>     		  singly_ll_iterator operator++(int) // 후행 증가
>     		  {
>     		      singly_ll_iterator result = *this;
>     		      ++(*this);
>     		      return result;
>     		  }
>     ```
>
> 6. **두 반복자가 같은지 판단하는 관계 연산자 함수를 friend로 정의**한다.
     >
     >     ```cpp
>     			friend bool operator==(const singly_ll_iterator &left, const singly_ll_iterator &right) {
>     	      return left.ptr == right.ptr;
>     	    }
>     			
>     	    friend bool operator!=(const singly_ll_iterator &left, const singly_ll_iterator &right) {
>     	      return left.ptr != right.ptr;
>     	    }
>     		};
>     ```
>
> 7. **begind()과 end() 함수를 추가, const 버전도 함께 추가**한다.
     >
     >     ```cpp
>     singly_ll_iterator begin() { return singly_ll_iterator(head); }
>     
>     singly_ll_iterator end() { return singly_ll_iterator(NULL); }
>     
>     singly_ll_iterator begin() const { return singly_ll_iterator(head); }
>     
>     singly_ll_iterator end() const { return singly_ll_iterator(NULL); }
>     ```
>
> 8. **기본 생성자, 깊은 복사를 위한 복사 생성자, 초기화 리스트를 사용하는 생성자를 추가**한다.
     >
     >     ```cpp
>     singly_ll() = default;
>     
>     singly_ll(const singly_ll &other) : head(NULL) {
>       if (other.head) {
>         head = new node{0, NULL};
>         auto cur = head;
>         auto it = other.begin();
>         while (true) {
>     	    cur->data = *it;
>     	
>     	    auto tmp = it;
>     	    ++tmp;
>     	    if (tmp == other.end())
>     		    break;
>     	
>     	    cur->next = new node{0, NULL};
>     	    cur = cur->next;
>     	    it = tmp;
>         }
>       }
>     }
>     
>     singly_ll(const std::initializer_list<int> &ilist) : head(NULL) {
>       for (auto it = std::rbegin(ilist); it != std::rend(ilist); it++)
>         push_front(*it);
>     	}
>     };
>     ```
>
> 9. main() 함수를 만들고 앞서 구현한 Class를 사용하는 코드를 추가한다.
     >
     >     ```cpp
>     int main() {
>       singly_ll sll = {1, 2, 3};
>       sll.push_front(0);
>     
>       std::cout << "첫 번째 리스트: ";
>       for (auto i: sll)
>         std::cout << i << " "; // 출력: 0 1 2 3
>       std::cout << std::endl;
>     
>       auto sll2 = sll;
>       sll2.push_front(-1);
>       std::cout << "첫 번째 리스트를 복사한 후, 맨 앞에 -1을 추가: ";
>       for (auto i: sll2)
>         std::cout << i << ' '; // 출력: -1 0 1 2 3
>       std::cout << std::endl;
>     
>       std::cout << "깊은 복사 후 첫 번째 리스트: ";
>     
>       for (auto i: sll)
>         std::cout << i << ' '; // 출력: 0 1 2 3
>       std::cout << std::endl;
>     }
>     ```
>
>
> std::initializer_list를 이용하여 연결 리스트를 초기화 하는 방법을 사용했다. push(), pop_front(), back()과 같은 함수를 사용할 수도 있다.
>
> **sll2가 깊은 복사에 의해 생성되었기 때문에 sll2에 새 원소를 추가해도 sll 리스트에는 여전히 4개의 원소가 있음을 확인할 수 있다.**
>