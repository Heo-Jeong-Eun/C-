기존 컨테이너를 감싸는 래퍼를 제공하는 이유는 코드에 좀 더 의미를 부여하고 싶거나, 의도하지 않은 함수를 실수로 사용하지 못하도록 제한, 특별한 인터페이스를 새롭게 제공하고 싶기 때문이다. 

이러한 자료 구조 중 하나가 stack이다. **stack은 데이터 처리와 보관을 위해 LIFO, 후입선출 구조를 사용한다.** 

기능적인 측면에서 stack은 컨테이너의 한쪽 끝에만 데이터를 삽입하거나 삭제할 수 있으며, 한쪽 끝이 아닌 위치에 있는 데이터는 접근하거나 변경할 수 없다. 

std::vector나 std::deque는 이러한 기능을 기본적으로 지원하기 때문에 stack을 구현하기 위한 용도로 사용할 수 있으나 약간의 문제가 있다. 

```cpp
std::deque<int> stk1;
stk1.push_back(1); // stack에 1 추가 {1}
stk1.push_back(2); // stack에 2 추가 {1, 2}
stk1.pop_back(1); // stack 맨 위 원소 제거 {1}
stk1.push_front(0); // 원래 stack에서는 지원하지 않는 동작이다. {0, 1}

std::stack<int> stk2;
stk1.push(1); // stack에 1 추가 {1}
stk1.push(2); // stack에 2 추가 {1, 2}
stk1.pop(1); // stack 맨 위 원소 제거 {1}
stk1.push_front(0); // 컴파일 에러 
```

위 코드 앞 부분에서는 std::deque를 사용해 stack 객체 stk1을 만들어 사용했다. 이 경우 push_front() 함수처럼 stack에서 사용하면 안되는 명령 코드를 작성하는 것을 막을 수 없다. 

또한 push_back()과 pop_back() 같은 함수 이름은 자료 구조 맨 뒤에 데이터를 추가하거나 삭제한다는 의미인데, stack으로 사용할 때에는 어느 위치에 데이터가 저장되는지 알 필요가 없다. 

이와 달리 std::stack를 사용하여 작성된 코드는 어떤 작업을 하는지 더 직관적으로 알 수 있다. 

std::stack은 std::deque으로 만든 간단한 래퍼로서 stack 자료 구조에서 꼭 필요한 인터페이스만을 제공한다. 이러한 방식으로 만들어진 것을 **컨테이너 어댑터**라고 한다. 

> **1.9.1 std::stack**
> 
> 
> **std::stack**은 보통 **std::deque를 기본 컨테이너로 사용**한다. 
> 
> std::stack은 stack이 기본적으로 제공해야 할 기능을 empty(), size(), top(), push(), pop(), emplace() 등의 함수로 제공한다. 
> 
> push() 함수는 기본 컨테이너의 push_back() 함수를 사용해 구현되고, pop() 함수는 pop_back() 함수를 사용하여 구현한다. 
> 
> top() 함수는 기본 컨테이너의 back() 함수를 사용하는데, 이는 stack에서 맨 위에 있는 데이터가 deque 구조에서는 맨 끝에 있는 원소이기 때문이다. 
> 
> 이처럼 **기본 컨테이너의 한쪽 끝에서만 원소의 추가 및 삭제를 수행함으로써 LIFO 특징을 제공**한다. 
> 
> stack의 구현을 위해 vector가 아닌 deque을 기본 컨테이너로 사용하는 것은 deque을 사용하면 원소 저장 공간을 재할당할 때 vector처럼 전체 원소를 이동할 필요가 없기 때문이다. 
> 
> 몇몇의 경우 특정 컨테이너가 더 좋은 효율을 보일 수는 있다. 
> 
> ```cpp
> std::stack<int, std::vector<int>> stk;
> std::stack<int, std::list<int>> stk;
> ```
> 
> stack의 모든 연산은 **시간 복잡도가 O(1)**이다. stack에서 기본 컨테이너로 함수 호출을 전달하는 과정은 컴파일러의 최적화에 의해 모두 인라인 형식으로 호출될 수 있어 여기서 발생하는 Overhead는 없다. 
> 

> **1.9.2 std::queue**
> 
> 
> LIFO 구조를 사용하는 std::stack과 달리 **FIFO 구조가 필요한 경우**도 많이 있으며, 이러한 경우 **std::queue 어뎁터를 사용할 수 있다.** 
> 
> std::queue는 stack과 비슷한 형태의 함수를 지원하며, 다만 LIFO 대신 FIFO를 지원하기 위해 그 의미와 동작이 조금 다르게 정의 되어 있다. 
> 
> 예를 들어 std::queue에서 push()는 std::stack에서의 push_back()을 의미하지만, pop() 함수와 달리 단순히 양 끝단에 있는 원소에 접근하고 싶을때에는 front()나 back() 함수를 사용한다. 
> 
> ```cpp
> std::queue<int> q;
> q.push(1); // 맨 뒤에 1을 추가 : {1}
> q.push(2); // 맨 뒤에 2를 추가 : {1, 2}
> q.push(3); // 맨 뒤에 3을 추가 : {1, 2, 3}
> q.pop(); // 맨 앞 원소를 제거 : {2, 3}
> q.push(4); // 맨 뒤에 4를 추가 : {2, 3, 4}
> ```
> 
> std::queue는 std::stack과 같은 이유로 std::deque을 기본 컨테이너로 사용하며, 앞서 사용한 모든 함수는 **시간 복잡도 O(1)**로 동작한다. 
> 

> **1.9.3 std::priority_queue**
> 
> 
> **std::priority_queue는 Heap이라고 불리는 매우 유용한 구조를 제공**한다. 
> 
> **Heap**은 컨테이너에서 **가장 작은 원소, 가장 큰 원소에 빠르게 접근할 수 있는 자료구조**이다. 최소, 최대 원소에 접근하는 동작은 O(1)의 시간 복잡도를 가진다. 
> 
> 원소 삽입은 O(log n)의 시간 복잡도로 동작하며, 원소 제거는 최소, 최대 원소에 대해서만 가능하다. 
> 
> 유의해야 하는 점은 최소, 최대 둘 중 하나에 대해서만 적용할 수 있으며, 최소와 최대에 한번에 빠르게 접근은 불가능하다는 것이다. 
> 
> 둘 중 어느 것에 빠르게 접근할 것인지는 **컨테이너 비교자**에 의해 결정된다. 
> 
> std::stack이나 stad::queue와 달리 std::priorty_queue는 기본적으로 std::vector를 기본 컨테이너로 사용하며, 필요한 경우 변경할 수 있다. 
> 
> **비교자는 기본적으로 std::less를 사용**한다. 그러므로 **기본적으로는 Max Heap이 생성**되며, 이는 최대 원소가 맨 위에 나타나게 됨을 의미한다.
> 
> 새로운 원소를 삽입할 때마다 최소, 최대 원소가 최상위에 위치하도록 설정해야 하기 때문에 단순하게 기본 컨테이너 함수를 호출하는 형태로 동작할 수 없다. 
> 
> 대신 비교자를 사용해 **최소, 최대 데이터를 맨 위까지 끌어올리는 Heapify 알고리즘**을 구현해야 한다.  
> 
> 이러한 연산은 컨테이너 크기에 대한 로그 형태의 시간을 소요, O(log n) 시간 복잡도로 표현된다. 
> 
> 여러 개의 원소를 이용해 **std::priority_queue를 초기화할 때에도 이런 작업이 수행**된다. 그러나 std::priority_queue 생성자는 단순히 초기화 원소에 대해 각각 삽입 함수를 호출하지 않는다. 
> 
> 대신 O(n) 시간 복잡도로 빠르게 동작하는 다른 힙 생성 알고리즘을 사용한다. 
> 

> **1.9.4 어댑터 반복자**
> 
> 
> 모든 어댑터는 각 자료구조에서 꼭 필요한 기능만 지원한다. std::stack, std::queue, std::priority_queue에서 모든 원소를 순회하는 작업은 필요 없고, **언제든 특정 위치에 있는 원소 하나만 참조할 수 있으면 된다.** 
> 
> 따라서 **STL은 이들 어댑터에 대해서는 반복자를 지원하지 않는다.** 
>