연속된 자료 구조에서는 데이터 중간에 자료를 추가하거나 삭제하는 작업이 매우 비효율적이기 때문에 연결 리스트와 같은 연결된 자료 구조를 사용하는 것이 좋다. 

**기본적인 연결 리스트를 구성**하려면 **포인터를 하나 가지고 있어야하고, new와 delete 연산자를 이용하여 메모리를 할당하고 해제할 수 있어야 한다.** 

C++은 기본적으로 연결 리스트에 대한 래퍼 클래스인 std::forward_list Class를 제공한다. 

성능 유지를 위해 std::forward_list는 전체적인 리스트의 크기를 반환하거나 또는 첫 번째 원소를 제외한 나머지 원소에 직업 접근하는 기능을 제공하지 않는다. 

즉, **맨 처음 원소에 접근하는 front() 함수는 제공하지만, 반대 방향의 원소로 이동하는 back() 같은 함수는 제공하지 않는다.** 단 원소의 삽입, 삭제, 순서 뒤집기, 분할을 위한 기능은 제공한다. 

이러한 기본적인 기능은 메모리 사용량이나 성능에 영향을 주지는 않는다. 

std::vector와 마찬가지로 std::forward_list도 **두 번째 Template 매개 변수에 사용자 지정 할당자를 지정**할 수 있다. 

> **1.5.1 std::forward_list에서 원소 삽입과 삭제**
> 
> 
> std::forward_list에서 **원소를 삽입**할 때에는 **push_front()**와 **insert()_after() 함수**를 사용한다. 
> 
> **push_front() 함수**는 **연결 리스트 맨 앞에 새로운 원소를 삽입**한다. std::forward_list는 마지막 원소에 직접 접근할 수 없으므로 push_back() 함수를 제공하지 않는다. 
> 
> **특정 위치에 원소를 삽입**하려면 insert()가 아니라 **insert_after() 함수를 사용**해야 한다. **연결 리스트에서 새로운 원소를 삽입한 후, 해당 위치 앞에 있는 원소의 next 포인터를 수정해야 하기 때문이다.** 
> std::forward_list에서 반대 방향으로 이동하는 것이 허용되지 않으므로 특정 원소 뒤에 새로운 원소를 삽입한 후, 해당 원소의 next 포인터를 수정하는 것이 타당하다. 
> 
> 원소 삽입은 **Node의 포인터 조작으로 구현**되므로 **삽입 후 다른 원소를 이동할 필요가 없다.** 원소 크기에 영향을 받지 않으며, 시간 복잡도는 O(1)이다. 
> 
> ```cpp
> std::forward_list<int> fwd_list = {1, 2, 3, 4, 5};
> 
> fwd_list.push_front(0); // 맨 앞에 0 추가 : {2, 3, 4, 5};
> 
> auto it = fwd_list.begin();
> 
> fwd_list.erase_after(it); // 맨 앞의 다음 원소를 삭제 : {2, 4, 5};
> 
> fwd_list.erase_after(it, fwd_list.end()); // 맨 앞 원소 다음부터 맨 마지막 원소까지 삭제 : {2}
> ```
> 

> **1.5.2 std::forward_list의 기타 멤버 함수**
> 
> 
> 반복자로 원소 위치를 지정해 삭제하는 erase() 함수 외에도 std::forward_list는 **원소 값을 검사하여 삭제하는 remove()와 remove_if() 함수도 제공**한다. 
> 
> **remove()** 함수는 삭제할 원소 값 하나를 매개 변수로 받는다. 이 함수는 저장된 데이터 타입에 등호 연산자를 사용하여 전달된 값과 일치하는 모든 원소를 찾아 삭제한다. 
> 
> 저장된 데이터 타입에서 등호 연산이 지원되지 않으면 remove() 함수는 사용할 수 없다. 오직 등호 연산에 근거해 원소를 삭제하며 다른 조건에 근거해 삭제 여부를 결정할 수 없다. 
> 
> **remove_if()** 함수는 데이터 원소 값 하나를 인자로 받아 bool 값을 반환하는 조건자 함수를 인자로 받는다. 그리고 조건자가 true를 반환하는 모든 데이터 원소를 리스트에서 삭제한다. 
> 

> **1.5.3 연결 리스트에서 remove_if() 함수를 이용한 조건부 원소 삭제**
> 
> 
> 연결 리스트를 사용하여 데이터를 저장하고, remove_if() 함수를 사용하여 특정 원소를 제거할 것이다. remove_if() 함수는 삭제할 원소 위치를 명시적으로 지정하는 것이 아니라 특정 조건에 해당하는 원소를 선별적으로 삭제할 때 사용한다. 
> 
> 1. 필요한 **Header File을 포함**시키고, citizen 구조체를 정의한다. 
>     
>     ```cpp
>     #include <string>
>     #include <iostream>
>     #include <forward_list>
>     
>     struct citizen
>     {
>     	std::string name;
>     	int age;
>     };
>     
>     std::ostream &operator << (std::ostream &os, const citizen &c)
>     {
>     	return (os << "[" << c.name << ", " << c.age << "]");
>     }
>     ```
>     
> 2. main() 함수를 작성하고, **std::forward_list를 사용**하여 몇몇 시민 정보를 **초기화**한다. 추후 다시 초기화 하는 것을 피하기 위해 복사본도 만들어준다. 
>     
>     ```cpp
>     int main()
>     {
>     	std::forward_list<citizen> citizens = {
>     		{"Kim", 22}, {"Lee", 25}, {"Park", 18}, {"Jin", 16}
>     	};
>     
>       auto citizens_copy = citizens; // 깊은 복사
>     
>       std::cout << "전체 시민: ";
>       for (const auto &c : citizens)
>     	  std::cout << c << " ";
>       std::cout << std::endl;
>     ```
>     
> 3. 나이 정보를 이용해 투표권이 없는 시민을 리스트에서 제거한다. 
>     
>     ```cpp
>     	citizens.remove_if([](const citizen &c) {
>     		// 나이가 19세보다 작으면 리스트에서 제거
>     		return (c.age < 19);
>     	});
>     
>     	std::cout << "투표권이 있는 시민: ";
>     	for (const auto &c : citizens)
>     		std::cout << c << " ";
>     	std::cout << std::endl;
>     ```
>     
>     **remove_if() 함수는 주어진 조건에 대해 참을 만족하는 원소를 모두 제거**한다. 이 경우 람다 표현식을 사용했다. 
>     
>     만약 조건이 복잡하다면 저장된 원소를 인자로 받아 bool 값을 반환하는 일반 함수를 사용해도 된다. 
>     
> 4. 내년에 새로 투표권이 생기는 사람을 출력한다. 
>     
>     ```cpp
>     	citizens_copy.remove_if([](const citizen &c) {
>     		return (c.age != 18);
>     	});
>     	
>     	std::cout << "내년에 투표권이 생기는 시민: ";
>     	for (const auto &c : citizens_copy)
>     		std::cout << c << " ";
>     	std::cout << std::endl;
>     }
>     ```
>     
> 
> **remove()**와 **remove_if()** 함수는 리스트 전체를 순회하면서 조건에 맞는 원소를 모두 삭제하므로 **O(n)의 시간 복잡도**를 갖는다. 
> 
> **std::forward_list**는 원소 데이터를 정렬하는 sort() **멤버 함수를 제공**한다. 
> 
> std::forward_list에서 제공하는 sort() 함수는 두 가지 형태를 지원하는데, 하나는 **< 연산자를 기반으로 정렬**하고, 다른 하나는 **매개 변수로 전달된 비교자를 사용**한다. 
> 
> 기본적으로 **std::less<velue_type>**을 비교자로 사용한다. 첫 번째 인자가 두 번째보다 작으면 ture를 반환하며, 사용자 정의 타입 원소를 사용할 경우 < 연산자가 재정의 되어 있어야 한다. 
> 
> 이외에도 다른 기준을 이용해 원소를 비교, 정렬하려면 **이항 조건자를 지정**할 수 있다. 
> 
> 두 가지 형태의 sort() 함수 모두 **선형 로그 시간 복잡도 O(nlogn)**을 갖는다. 
> 
> ```cpp
> std::forward_list<int> list1 = {23, 0, 1, -3, 34, 32};
> list1.sort() // 오름차순, {-3, 0, 1, 23, 32, 34} 출력
> list1.sort(std::greater<int>()); // 내림차순, {34, 32, 23, 1, 0, -3} 출력
> ```
> 
> 그러나 **연결 리스트 같은 자료 구조**는 특정 원소에 임의의 접근이 불가능하므로 **std::sort()를 사용할 수 없다.** 또한 std::forward_list에서 사용하는 반복자는 std::array와 std::vector와 다르다. 
> 
> std::forward_list에서 제공하는 다른 멤버 함수는 **reverse()**와 **unique()**가 있다. 
> 
> **reverse()** 함수는 저장된 원소의 순서를 역순으로 변경한다. 이때 걸리는 시간은 **리스트 원소 개수에 비례**하며, **시간 복잡도는 O(n)**이다. 
> 
> **unique()** 함수는 리스트에서 홀로 나타나는 원소는 놔두고, 인접하여 중복되는 원소에 대해서는 첫 번째만 남겨두고 나머지는 제거한다. 
> 
> 이 함수는 두 원소가 같은지 판단하는 방식에 따라 두 가지 형태로 제공되는데, 하나는 **인자가 없는 형태**이며 이때 **원소 타입 등호 연산자를 사용**하여 같은지를 판단한다. 
> 
> 다른 하나는 **bool 값을 반환**하는데, 이는 unique() 함수가 각각의 원소를 나머지 전체와 비교하는 형태로 동작되는 것이 아님을 의미한다. 
> 
> **서로 인접한 원소끼리 같은지 판단 후, 서로 같으면 앞에 있는 원소를 남기고 뒤에 있는 원소는 제거**한다. 따라서 **리스트 전체에서 유일한 원소들만 남게 만들려면 먼저 리스트를 정렬한 후 unique()를 사용**해야 한다. 
> 
> ```cpp
> std::forward_list<int> list1 = {2, 53, 1, 0, 4, 10};
> list1.reverse(); // {10, 4, 0, 1, 53, 2}; 출력
> 
> list1 = {0, 1, 0, 1, -1, 10, 5, 5, 10, 0};
> list1.unique(); // {0, 1, 0, 1, -1, 10, 5, 10, 0}; 출력 
> 
> list1 {0, 1, 0, 1, -1, 10, 5, 5, 10, 0};
> list1.sort(); // {-1, 0, 0, 0, 1, 1, 5, 5, 10, 10}; 출력
> list1.unique(); // {-1, 0, 1, 5, 10} 출력 
> ```